n = int(input())

def func(n):
    temp = [0] * 1000001
    for i in range(2, n + 1):
        temp[i] = temp[i-1] + 1 # 

        if i % 2 == 0: # 2로 나누어 떨어지면? 최소값 비교해서 집어넣게
            temp[i] = min(temp[i], temp[i//2] + 1)
        
        if i % 3 == 0: # 3으로 나누어 떨어지면, 최소값 비교하여 집어넣기
            temp[i] = min(temp[i], temp[i//3] + 1)
        
    return temp[n]

print(func(n))


# * n이 1일 때는 이미 1이므로 연산이 필요하지 않다. 즉 d[1] = 0이다. 그래서 코드는 for문을 돌 때 시작점을 2로 설정함

# * n이 2일 때는 2로 나누어 떨어지므로 바로 2/2를 진행하고 나면 값은 1이 된다. 2가 1이 되기까지는 1번의 연산을 필요로 하므로 d[2] = 1

# * n이 3일 때 역시 3으로 나누어지므로 바로 3/3을 진행하고, 값은 1이 된다. 3이 1이 되기까지는 1번의 연산이 필요하므로 d[3] = 1

# * n이 4일 때는 2로 나누어 떨어지므로 4 / 2를 진행하고 해당 값은 2가 된다. 이제 이 값을 1로 만들기 위해선 또 다시 2로 나눈다. 2 / 2 는 1이므로 연산이 종료
#   n이 4일 때는 4 / 2 -> 2 / 2 = 1, 총 2번의 연산을 진행하였으므로 d[4] =2 가 된다.

# * n이 5일 때는 2나 3으로 나누어지지 않으므로 -1을 진행한다. 그러면 값은 4가 되고 이 4는 다시 2로 나누어 2가 되고, 
#   이 2는 또 2로 나누어 1이 된다. 즉, 5-1 -> 4 / 2 -> 2 / 2 = 1로, 
#   총 3번의 연산을 진행하여 d[5] = 3

# * n이 6일 때는 2와 3 모두로 나누어진다. 두 가지 경우가 존재함.
#   6 / 3 -> 2 / 2 = 1 
#   6 / 2 -> 3 / 3 = 1 이므로, 
#   처음에 2로 나누던 3으로 나누던 모두 2번의 연산을 필요로 한다.  d[6] = 2

# * n이 7일 때는 2와 3 모두 나누어지지 않으므로 -1
#   그럼 값은 6이 되고, 6은 또 다시 2와 3 모두로 나누어진다. 
#   두 방법 모두 진행하더라도 
#   6 / 3 -> 2 / 2 = 1 
#   6 / 2 -> 3 / 3 = 1 이므로, 
#   n[7] = 7 - 1 -> 6 / 3 -> 2 / 2 = 1 
#   혹은 7 - 1 -> 6 / 2 -> 3 / 3 = 1 
#   3번의 연산을 필요로 하여 d[7] = 3


# n이 7일 때 n에서 1을 빼고나면 6이 되고, 6을 1로 만드는 연산은 n이 6일 때의 연산 값과 같다.
# 그렇다면 n이 7일 때는 n에서 1을 빼는 연산 횟수 1번과, 6을 1로 만드는 d[6] 값을 더하면 d[7] 값을 구할 수 있음.
# 식으로 표현하면 d[7] = 1 + d[6]

# n이 6일 때,
# n을 2로 나누고 나면 n은 3이 되고, 3을 1로 만드는 연산횟수는 d[3]이다.
# 즉, n이 6일 때는 n을 2로 나누는 연산 횟수 1번과 3을 1로 만드는 d[3] 값을 더하면 d[6] 값을 구할 수 있음.
# 이것을 식으로 표현하면 d[6] = 1+ d[6//2] 
# 물론 n을 처음에 2가 아닌 3으로 나누면 d[6] = 1 + d[6//3]이 될수도 있음.
# 이럴 땐, 두 값을 비교해 더 작은 값을 d[6]에 삽입(최솟값을 출력해야 하므로.)
# 이런 식으로 for문을 돌면서 n을 우리가 입력받은 값까지 돌게 되면 d[n]에는 n번째 값을 1로 만드는 최소 연산 횟수를 구할 수 있음