# 지구 -> 0
# 행성 1, 2, ....n-1을 순서대로 확인 후 지구로 돌아오는 것이 비용상 최적
# 모든 정수 1 <= i < n 에 대해, 행성 i는 지구가 아니다.
# 초고속 걷기 기계는 지구를 벗어나면 속도가 줄어든다
# 평행우주는 일정한 가격을 두고 있기 때문에, 필요한 속도의 양의 정수 배로도 다음 지역으로 이동할 수 있다.
# 지구의 대체 행성으로 적합한지는 도착한 뒤에 알 수 있다.
# 행성 1에 가기 위해 필요한 것보다 세배의 속도로, 행성 2의 경우 두 배의 속도로 이동하면, 지구에서는 900의 속도만 쌓으면 된다.
# 300 400 500 400 300 


# 그리디 알고리즘
# 마지막 행성에서는 그 행성의 속도와 같은 값이면 된다. (최소값을 구해야 하기 때문에.)

# 현재의 속도가 i 행성의 속도보다 작으면 현재 속도를 i 행성 속도로 재 할당 -> 정방향으로 한다면 속도를 떨어뜨린 것과 같다.

# 현재의 속도가 i 행성의 속도보다 크면? 2가지 경우... 양의 정수 배로 재 할당해야 한다. -> 2가지 경우로 나뉜다. 
# -> 1. 현재 속도가 i 행성에 도달하기 위한 속도의 양의 배수라면? 그대로, 
# -> 2. i행성의 속도의 양의 배수가 아니면, 현재 속도값보다 크게 하면서, i 행성속도의 양의 배수로 만들기



N = int(input())
speed = list(map(int, input().split()))
present = speed[-1]
# 역방향 탐색
for i in range(N-2, -1, -1): 
    if speed[i] > present: # 행성속도가 현재속도보다 크다면?
        present = speed[i] # 현재속도를 행성속도로 재할당

    else: # 행성속도가 현재속도보다 작다면?
        if present % speed[i]: # 양의 정수배가 되지 않는다면 아래 코드블록을 실행 
            present = (present//speed[i]+1) * speed[i] # 현재 속도를 정수배이면서, 최소값으로 재할당.

print(present)
