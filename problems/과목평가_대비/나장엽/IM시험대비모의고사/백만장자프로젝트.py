#최대한의 이득
# 연속된 n일동안의 물건의 매매가를 예측하여 알고있다.
# 당국의 감시망에 걸리지 않기 위해 하루에 최대 1만큼 구입할 수있다
# 판매는 얼마든지 할 수 있음
# 예를 들어 3일 동안의 매매가 가 1,2,3 이라면 처음 두날에 원료를 구매하여 마지막 날에 팔면 3의 이익..


# 첫번째 줄에 테스트 케이스의 수
# 테스트 케이스 별로 첫줄에는 자연수
# 둘째 줄에는 각 날의  매매가를 나타내는 n개의 자연수들이 공백으로 구분되어 순서대로 주어진다.
# 각 날의 매매가는 10,000 이하이다

# 출력 
# 테스트 케이스마다 #1 4053
# 3
# 2
# 522 4575
# 5
# 6426 9445 8772 81 3447
# 
# 10
# 629 3497 7202 7775 4325 3982 4784 8417 2156 1932
# 사고  사고 사고11328 -23325     13091 -25251  팔고   사고  사고  사고  팔고 ----> 틀린방법
# 설계
# 최고가 - 현재가 -> 최대이득 
# 하나씩 탐색하면서 최고가에서는 물건을 사지 않는다.. 최고가에만 팔기
# !최고가 - 현재가 => 최대이득
# !현재가가 최고가 보다 크다면 최고가를 변경 최고가에서 빼면서 이익을 누적시키면 될듯

# 3
# 2
# 522 4575   맨 뒤의 값을 max로 설정하는것이 point임.  1일차에 사서 2일차에 팔기  4675 - 522
# 5
# 6426 9445 8772 81 3447 / 3447 - 81, 
# 
# 10
# 629 3497 7202 7775 4325 3982 4784 8417 2156 1932

T = int(input())

for tc in range(1, T+1):
    n = int(input())
    price = list(map(int, input().split()))
    # 최고가 - 현재가 => 최대 이익
    # 거꾸로 탐색하기~가 포인트.
    
    max = price[-1]
    profit = 0
    
    for i in range(n-2, -1, -1):
        # 현재가가 최고가보다 크다면 최고가를 현재가로 갱신
        if price[i] >= max:
            max = price[i]
        # 현재가가 최고가보다 작다면
        # 최고가 - 현재가 이익 누적시키기
        else:
            profit += max - price[i]
    print("#{0} {1}".format(tc, profit))